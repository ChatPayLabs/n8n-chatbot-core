-- BOOKING

create table public.sal_booking (
  id bigint generated by default as identity not null,
  uid text null default nanoid (16, '123456789ABCDEFGHIJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'::text),
  book_no text null,
  book_prefix text null,
  full_book_no text null,
  created_at timestamp with time zone null default now(),
  status text null default 'NEW'::text,
  user_id text null,
  user_name text null,
  user_phone text null,
  media text null,
  start_at timestamp with time zone null,
  end_at timestamp with time zone null,
  from_location text null,
  to_location text null,
  stops bigint null default '0'::bigint,
  distance text null,
  duration text null,
  price text null,
  luggages text null,
  pets text null,
  remarks text null,
  summary text null,
  datetime text null,
  from_district text null,
  to_district text null,
  country text null,
  session_id text not null,
  channel_no text not null,
  service_no text not null,
  provider_no text null,
  agent_no text null,
  member_no text null,
  closing_at timestamp with time zone null,
  confirmed_at timestamp with time zone null,
  returned_at timestamp with time zone null,
  cancelled_at timestamp with time zone null,
  void_at timestamp with time zone null,
  closed_at timestamp with time zone null,
  agent_score bigint null default '0'::bigint,
  opened_at timestamp with time zone null,
  stop_locations text null,
  selection bigint null default '0'::bigint,
  tips text null,
  chat_id text null,
  message_id text null,
  language text null default 'English'::text,
  currency text null,
  timezone text null,
  hold_at timestamp with time zone null,
  timestamp bigint null,
  google_cal_id text null,
  google_cal_url text null,
  google_cal_id2 text null,
  google_cal_url2 text null,
  constraint sal_booking_pkey primary key (id),
  constraint sal_booking_full_book_no_key unique (full_book_no),
  constraint sal_booking_uid_key unique (uid),
  constraint sal_booking_member_no_fkey foreign KEY (member_no) references sys_member (member_no) on update CASCADE,
  constraint sal_booking_channel_no_fkey foreign KEY (channel_no) references sys_channel (channel_no) on update CASCADE,
  constraint sal_booking_provider_no_fkey foreign KEY (provider_no) references sys_provider (full_provider_no) on update CASCADE,
  constraint sal_booking_service_no_fkey foreign KEY (service_no) references sys_service (full_service_no) on update CASCADE,
  constraint sal_booking_agent_no_fkey foreign KEY (agent_no) references sys_agent (full_agent_no) on update CASCADE
) TABLESPACE pg_default;

alter table public.sal_booking alter column uid set default nanoid(16, '123456789ABCDEFGHIJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');

-- SEQ

DROP SEQUENCE IF EXISTS public.sal_booking_book_no_seq;
CREATE SEQUENCE public.sal_booking_book_no_seq
  START WITH 10001
  INCREMENT BY 1
  MINVALUE 10001
  CYCLE;

-- FUNCTION on_sal_booking_insert
drop function if exists public.on_sal_booking_insert cascade;

create function public.on_sal_booking_insert () returns trigger
set
  search_path = '' as $$ -- PRIVATE FUNCTION
declare
  _sys_channel public.sys_channel;
begin
  -- find channel
  SELECT * FROM public.sys_channel WHERE channel_no = new.channel_no INTO _sys_channel;

  -- override
  new.country = _sys_channel.country;
  new.currency = _sys_channel.currency;
  new.timezone = _sys_channel.timezone;

  SELECT TO_CHAR(NOW(), 'YY') || LPAD(EXTRACT(DOY FROM NOW())::text, 3, '0') into new.book_prefix; -- YYDDD
  new.book_no := nextval('public.sal_booking_book_no_seq')::text; -- #####+
  new.full_book_no := UPPER(new.country) || '-' || new.book_prefix || '-' || new.book_no;

return new;
end;
$$ language plpgsql security definer;

create trigger on_sal_booking_insert before insert on sal_booking for each row
execute function on_sal_booking_insert ();

-- FUNCTION sal_booking_book_no_reset
drop function if exists public.sal_booking_book_no_reset cascade;

create function public.sal_booking_book_no_reset () returns void
set
  search_path = '' as $$ -- private
declare
begin
  PERFORM setval('sal_booking_book_no_seq', 10001);
end;
$$ language plpgsql security definer;

-- CRON
SELECT cron.unschedule((select jobid from cron.job where command = 'SELECT sal_booking_book_no_reset();'));
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'sal_booking_book_no_reset') THEN
    PERFORM cron.unschedule('sal_booking_book_no_reset');
  END IF;
END $$;
SELECT cron.schedule(
  'sal_booking_book_no_reset',
  '0 0 * * *',
  'SELECT sal_booking_book_no_reset();'
);

select * from cron.job;

-- FUNCTION sal_booking_cleanup
drop function if exists public.sal_booking_cleanup cascade;

create function public.sal_booking_cleanup () returns void
set
  search_path = '' as $$ -- private
declare
begin
  -- delete all sal_booking_new status NEW, CANCELLED created 60 minutes ago
  delete from public.sal_booking where
    status IN ('NEW', 'CANCELLED')
    and created_at < now() - interval '60 minutes';
end;
$$ language plpgsql security definer
set statement_timeout to '5min'; -- timeout in 5 minutes

-- CRON
SELECT cron.unschedule((select jobid from cron.job where command = 'SELECT sal_booking_cleanup();'));
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM cron.job WHERE jobname = 'sal_booking_cleanup_60m') THEN
    PERFORM cron.unschedule('sal_booking_cleanup_60m');
  END IF;
END $$;
SELECT cron.schedule(
  'sal_booking_cleanup_60m',
  '*/60 * * * *',
  'SELECT sal_booking_cleanup();'
);

select * from cron.job;
